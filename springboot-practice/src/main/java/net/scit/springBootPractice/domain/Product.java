package net.scit.springBootPractice.domain;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * 엔티티는 데이터베이스의 테이블을 자바의 객체로 대응시키는 클래스입니다.
 * 이를 ORM(Object-Relational Mapping)기술이라 하며,
 * 이 기술을 사용하는 이유는, 데이터베이스에 저장되어 있는 데이터인 레코드를
 * 자바에서 데이터를 다루는 방식인 객체로 변환하여 다루기 위함입니다.
 * 엔티티와 레코드는 매우 밀접하게 연관되어 있으며,
 * 중요한 부분이기 때문에, 항상 주의를 기울여야합니다.
 *
 * 여러분이 유념하셔야할 점은, 엔티티는 어디까지나 자바의 클래스이기 때문에,
 * 아무리 레코드와 밀접하게 연관되어 있다고 하더라도, 자바의 객체로 봐야한다는 것입니다.
 * 즉, 엔티티 클래스의 필드값 변경이나, 엔티티와의 관계 역시, 자바의 객체를 다루는 것과
 * 동일한 관점에서 생각하셔야합니다.
 *
 * 엔티티 클래스는 만드실 때, 먼저 가능한 순수한 자바 클래스를 만든다고 생각하시고 만드시고,
 * 그 위에, 애노테이션을 적절하게 붙여서 테이블과 대응시킨다고 생각하시면 됩니다.
 *
 * 애노테이션을 붙이면 애노테이션에 들어가는 값들이 있죠?
 * 이 값들이 언제 어떻게 적용되냐면, 엔티티를 리포지토리에서 저장할 때(리포지토리의 메서드를 호출하고 나서),
 * 리포지토리는 jpa 객체에게 엔티티의 정보를 전달하는데요,
 * 이 정보를 전달받은 jpa 객체에서는 데이터베이스에 전달하기 위한 sql을 생성합니다.
 * 바로 이때, 만약 사전에 지정한 조건에 위반되는 값이 있다면,
 * sql을 데이터베이스로 전송하지 않고 예외를 발생시킵니다.
 * 즉, 불필요한 데이터 전송을 미연에 방지하는 것입니다.
 *
 * 이제, 하나하나 애노테이션의 역할을 설명 드리겠습니다.
 */
/*
    수정자(세터)를 자동 생성합니다. 수정자는 필드의 값을 변경할 때 사용하는 메서드이나,
    실무에서는 권장되지 않습니다. 왜냐하면, 수정자를 생성하는 자체로 개발자의 의도치않은 수정자 호출에 대한
    오류가능성을 높이기 때문입니다. 또한, 이렇게 클래스 레벨에서 애노테이션을 붙이게 될 경우, 무분별하게 모든 필드에 대한
    수정자를 생성하기 때문에 더 위험합니다. 그리고 이렇게 자동으로 생성된 수정자에는 엔티티에서 사용되는 값
    (예를 들어 데이터베이스 레코드의 제약 조건에 위배되는 값 등)이 들어왔을 경우 이를 제지할 수 있는 방법이 없습니다.
    따라서 필드값의 수정이 필요할 경우, 직접 해당 수정에 필요한 메서드를 만드는 것이 가장 좋습니다.
    정리하면 필드값을 수정하는 방법은 2가지가 있겠습니다.
    1. 클래스가 아닌 필드에 @Setter를 적용하는 방법
    2. 수정자가 아닌, 조금 더 객체의 행동 양식에 걸맞은 메서드를 생성하는 방법
    둘중에서는 2번이 더 권장되는 방법이나,
    아주 단순한 애플리케이션에서는 1번도 크게 잘못된 방법은 아닙니다.
 */
@Setter
/*
    조회자(게터)를 자동 생성합니다.
    조회자는 값을 조회만하므로 특별히 주의할 필요는 없습니다.
    하지만 필요없는 조회자를 만드는 것은 근본적으로는 좋은 방법이 아닙니다.
    따라서 조회자도 원래는 필드별로 필요에 따라 조회자를 만들어야하지만,
    클래스에 @Getter를 적용해서 자동생성해도 큰 문제는 되지 않습니다.
 */
@Getter
/*
    엔티티임을 지정합니다.
    이 애노테이션이 있어야만 엔티티로서 기능을 할 수 있습니다.
    엔티티로서 지정된 클래스의 인스턴스는 jpa로부터 추적되어서,
    엔티티를 다루는 것으로 데이터베이스의 레코드를 다룰 수 있게합니다.
    이 애노테이션이 달리면, 엔티티로서 기능하기 위한 다른 추가 설정도 약간 필요한 부분이 있습니다.
    예를 들면 기본생성자와 같은 것들입니다.
    엔티티 애노테이션을 달면 반드시 기본생성자(protected 레벨 이상)를 생성해아함을 기억해주세요.
 */
@Entity
/*
    빌더 패턴의 메서드를 생성합니다.
    빌더 패턴이라는 것은 원래 생성자에 필요한 파라미터가 4개 이상일 때,
    너무 많은 파라미터를 하나의 생성자로 호출하면, 생성자 호출시의 코드길이가 너무 길어지는 문제와,
    타입이 같은 파라미터가 연속해서 있을 경우, 잘못된 순서로 호출하는 문제를 막기 위해
    고안된 것입니다.
    빌더는 따라서 값을 넣어줘야하는 필드가 4개 이상일 경우의 하나의 전략으로서 고려해주시면 됩니다.
    @Builder 애노테이션은 클래스뿐 아니라 생성자에 붙일 수도 있습니다.
    사실은 필요한 생성자에 선택적으로 붙이는 게 더 좋습니다.
    그렇게 하면, 개발자가 직접 의도한 프로그래밍 로직이 담긴 생성자를 빌더 메서드로 호출하는 것이 가능해져,
    개발자의 의도를 더 명확히 할 수 있습니다.
    빌더 메서드의 마지막에 .build()를 호출하는 시점에 생성자를 호출한다고 생각하시면 됩니다.
    참고로 @Builder에 파라미터 값을 지정하는 것으로 빌더 메서드의 이름을 지정할 수도 있습니다.
 */
@Builder
/*
    모든 필드를 파라미터로 가지는 생성자를 자동 생성합니다.
 */
@AllArgsConstructor
/*
    파라미터가 없는 생성자를 자동 생성합니다.
    파라미터로 접근 지정자를 지정할 수 있습니다.
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
/*
    어떤 테이블에 이 엔티티를 대응시킬지를 지정합니다.
    상세한 테이블과의 대응에 대한 정보는 파라미터로 지정할 수 있습니다.
    사실은 이 애노테이션은 달지 않아도 됩니다.
    만약 달지 않으면 @Table 애노테이션의 기본값이 적용되며,
    마치 인자가 없이 @Table만 달린 상태인 것 처럼 엔티티가 동작합니다.
    하지만 테이블과의 대응을 확실히 명시하기 위해서,
    적절한 파라미터값과 함께 붙여주는 것이 좋습니다.
 */
@Table(name = "product")
/*
    이 애노테이션은
    @CreationTimeStamp, @LastModifiedDate와 같은,
    자동 값 주입 기능을 사용할 때 필요한 애노테이션입니다.
    이 애노테이션이 없으면 자동으로 값이 주입되지 않으며,
    이 애노테이션이 달렸을 때 어떤 값을 주입할지는,
    개발자의 필요에 따라 직접 지정해 줄 수도 있습니다.
 */
@EntityListeners(AuditingEntityListener.class)
public class Product {
    /*
        이 필드가 테이블의 기본 키임을 지정합니다.
        엔티티에는 @Id를 이용하여 반드시 하나의 기본키를 지정해야합니다.
        이 필드를 이용해서 jpa에는 엔티티를 추적하고 비교하는 등의 관리를 하기 때문입니다.
     */
    @Id
    /*
        테이블의 기본키가 개발자가 직접 값을 넣는 것이 아닌,
        자동 생성을 이용함을 명시합니다. 이 자동 생성의 방법은 데이터베이스마다 다르므로,
        반드시 데이터베이스가 달라지면 그에 맞춰 검토해야합니다.
        그 자동생성 전략들 중에서도 IDENTITY라는 전략은, 엔티티를 저장하는 것으로
        테이블에 값을 삽입할 때, 엔티티를 저장처리하는 것과 동시에 테이블에 값을
        삽입하는 전략입니다.
        그렇다는 것은 그렇지 않은 전략도 있다는 말이겠죠?
        jpa에서는 필요에 따라 여러 기본키 전략을 채택할 수 있도록 되어있습니다.
     */
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_seq")
    private Integer seq;

    @Column(name = "name", unique = true, nullable = false)
    private String name;

    /*
        이 애노테이션은 @Builder를 사용할 때,
        기본값을 사용할 수록 할 수 있도록하는 애노테이션입니다.
        builder().build()로 생성자를 호출할 때
        이 필드를 초기화 하지 않더라도, 기본값을 적용해줍니다.
     */
    @Builder.Default
    @Column(name = "stock", nullable = false)
    private int stock = 0;

    @Column(name = "description")
    private String description;

    @Column(name = "category")
    private String category;

    @Builder.Default
    @Column(name = "price", nullable = false)
    private int price = 0;

    /*
        엔티티의 값이 데이터베이스에 저장될 때,
        자동으로 날짜값이 입력되도록 명시하는 애노테이션입니다.
        @EntityListeners가 없으면 동작하지 않습니다.
     */
    @CreationTimestamp
    @Column(name = "creation_date")
    private LocalDateTime creationDate;

    /*
        엔티티의 값이 수정되어 데이터베이스에 저장될 때,
        자동으로 날짜값이 입력되도록 명시하는 애노테이션입니다.
        @EntityListeners가 없으면 동작하지 않습니다.
     */
    @LastModifiedDate
    @Column(name = "update_date")
    private LocalDateTime updateDate;

    /*
        1:다 연관관계 맵핑을 해줍니다.
        기본적으로는 다:1 연관관계 맵핑만 해줘도 연관관계 맵핑은 이미 된것입니다.
        1:다의 연관관계 맵핑은, 순전히 연관된 엔티티간의 참조를 편하게 하기위해 사용하는 것입니다.
        필요없는 코드는 작성하지 않는 것이 언제나 좋습니다.
        따라서 양방향 연관관계가 필요하지 않으면 안하는게 좋습니다.
        여기서는 상품 -> 리뷰의 조회가 빈번하게 일어나는 경우이므로
        일대다 맵핑을 해주었습니다.

        그리고 일대다 맵핑을 할 때에는 꼭 new ArrayList<>()로 초기화를 해주는 것이 좋습니다.
        그렇지 않으면 실수로 인한 NullPointException이 일어날 확률이 매우 높습니다.
     */
    @OneToMany(mappedBy = "product")
    @Builder.Default
    private List<Review> reviews = new ArrayList<>();
}
